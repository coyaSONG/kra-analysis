# GPT-5 프롬프트 가이드

GPT-5는 당사의 최신 플래그십 모델로, 에이전틱(Agentic) 작업 수행 능력, 코딩, 순수 지능, 그리고 조정 가능성(steerability)에서 큰 도약을 이루었습니다.

기본 설정만으로도 다양한 분야에서 훌륭한 성능을 낼 수 있지만, 이 가이드에서는 실제 업무에 모델을 학습·적용하며 얻은 인사이트를 바탕으로 출력 품질을 극대화하는 프롬프트 팁을 다룹니다. 에이전틱 작업 성능을 끌어올리는 방법, 지시 준수(instruction adherence)를 보장하는 방법, 새로운 API 기능 활용법, 프런트엔드 및 소프트웨어 엔지니어링 작업을 위한 코딩 최적화 전략, 그리고 AI 코드 에디터 Cursor가 GPT-5와 함께 수행한 프롬프트 튜닝에서 얻은 핵심 인사이트를 소개합니다.

최선의 관행을 적용하고 표준 도구를 적극 채택함으로써 의미 있는 성장을 확인했으며, 이 가이드와 함께 우리가 제공하는 [프롬프트 최적화 도구](https://platform.openai.com/chat/edit?optimize=true)가 여러분의 GPT-5 활용을 위한 발판이 되기를 바랍니다. 단, 프롬프트는 만능 해법이 아닙니다. 이 가이드를 토대로 실험하고 반복하며 여러분의 문제에 가장 적합한 해법을 찾아보시길 권합니다.


## 에이전틱 워크플로의 예측 가능성

우리는 개발자를 염두에 두고 GPT-5를 학습시켰습니다. 도구 호출(tool calling), 지시 준수, 장문 컨텍스트 이해를 한층 강화해 에이전틱 애플리케이션의 최적 기반 모델로 설계했습니다. 에이전틱·도구 호출 플로우에 GPT-5를 채택한다면, 도구 호출 간 추론이 보존되어 더 효율적이고 지능적인 출력을 제공하는 [Responses API](https://platform.openai.com/docs/api-reference/responses)로의 업그레이드를 권장합니다.

### 에이전틱 성향(적극성) 제어
에이전틱 스캐폴드는 제어 강도가 매우 넓은 스펙트럼을 가집니다. 어떤 시스템은 의사결정 대부분을 모델에 위임하는 반면, 다른 시스템은 강한 분기 로직으로 모델을 엄격히 통제합니다. GPT-5는 이 스펙트럼 전반에서 작동하도록 학습되어, 모호한 상황에서의 상위 수준 의사결정부터 초점이 뚜렷한 과제를 정확하게 수행하는 것까지 모두 잘 수행합니다. 이 절에서는 GPT-5의 에이전틱 적극성을 어떻게 보정할지—즉, 주도성(proactivity)과 명시적 지시 대기 사이의 균형—를 다룹니다.

#### 과도한 적극성 낮추기(less eagerness)
기본적으로 GPT-5는 에이전틱 환경에서 정확한 답을 내기 위해 맥락 수집을 철저하고 포괄적으로 수행합니다. 도구 호출의 여파를 줄이고 최종 답안에 도달하는 지연(latency)을 최소화하려면 다음을 시도해 보세요.

- `reasoning_effort`를 낮춤: 탐색 깊이는 줄이되 효율성과 지연을 개선합니다. 많은 워크플로가 `medium` 또는 `low`에서도 일관된 결과를 냅니다.
- 문제 공간을 탐색하는 기준을 프롬프트에 명확히 정의: 모델이 불필요하게 많은 아이디어를 탐색·추론할 필요를 줄입니다.

```
<context_gathering>
Goal: 필요한 맥락을 빠르게 확보. 발견(디스커버리)은 병렬화하고, 실행 가능해지는 즉시 중단.

Method:
- 넓게 시작해 점진적으로 쪼개진 하위 쿼리로 확장.
- 병렬로 다양한 쿼리를 발사하고, 각 쿼리의 상위 결과를 읽음. 경로를 중복 제거하고 캐시; 같은 쿼리를 반복하지 않음.
- 맥락 과탐색을 피함. 필요 시, 하나의 병렬 배치로 타깃 검색을 수행.

Early stop criteria:
- 변경할 정확한 콘텐츠를 특정할 수 있음.
- 상위 결과가 한 영역/경로로 수렴(~70%).

Escalate once:
- 신호가 상충하거나 범위가 모호하면, 한 번의 정제된 병렬 배치를 수행한 뒤 진행.

Depth:
- 변경할 심볼이나 의존하는 계약만 추적; 필요한 경우가 아니면 전이적 확장을 피함.

Loop:
- 일괄 검색 → 최소 계획 → 작업 완료.
- 검증이 실패하거나 새로운 미지점이 생길 때만 재검색. 더 많은 검색보다 실행을 선호.
</context_gathering>
```

최대한 규범적으로 운영하고 싶다면, 아래와 같이 고정된 도구 호출 예산을 설정할 수도 있습니다. 예산은 원하는 탐색 깊이에 따라 달라질 수 있습니다.

```
<context_gathering>
- Search depth: 매우 낮음
- 완전히 정확하지 않을 수 있어도 가능한 한 신속하게 올바른 답을 제공하는 쪽으로 강하게 바이어스.
- 보통 절대 최대 2회의 도구 호출.
- 더 조사할 시간이 필요하다고 판단되면, 최신 발견 사항과 열린 질문을 사용자에게 공유. 사용자가 확인하면 계속 진행 가능.
</context_gathering>
```

핵심 맥락 수집 행동을 제한할 때는, 모델이 더 짧은 컨텍스트 수집 단계로도 만족할 수 있도록 탈출구(escape hatch)를 프롬프트에 명시해 주는 것이 유용합니다. 위 예시의 “완전히 정확하지 않을 수 있어도” 같은 문구가 대표적입니다.

#### 더 높은 적극성 유도하기(more eagerness)
반대로 모델의 자율성을 높이고 도구 호출 지속성을 강화하며, 확인 질문이나 사용자에게 조기 반환하는 빈도를 줄이고 싶다면, `reasoning_effort`를 높이고 아래와 같은 프롬프트를 사용해 끈기 있는(problem-persistent) 태스크 완수를 유도하세요.

```
<persistence>
- 당신은 에이전트입니다. 사용자의 요청이 완전히 해결될 때까지 계속 진행하고, 확신할 때만 턴을 종료하세요.
- 문제 해결을 확신할 때만 턴을 종료하세요.
- 불확실함을 만나도 멈추거나 사용자에게 되돌리지 마세요 — 가장 합리적인 접근을 조사하거나 추론해 계속 진행하세요.
- 가정을 사용자에게 확인·명료화하지 마세요. 나중에 언제든 조정할 수 있습니다 — 가장 합리적인 가정을 선택해 진행하고, 완료 후 사용자 참고용으로 문서화하세요.
</persistence>
```

일반적으로 에이전틱 태스크의 종료 조건을 명확히 서술하고, 안전한 행동과 위험한 행동을 구분하며, 모델이 사용자에게 반환해도 되는 조건을 정의하는 것이 도움이 됩니다. 예를 들어 쇼핑 도구 세트에서는 결제·체크아웃 도구에 더 낮은 불확실성 임계값을 설정하고, 검색 도구는 매우 높은 임계값을 설정할 수 있습니다. 코딩 환경에서는 파일 삭제 도구는 낮은 임계값, `grep` 검색 도구는 높은 임계값을 설정하는 식입니다.

### 도구 프리앰블(tool preambles)
사용자가 관찰하는 에이전틱 궤적에서는, 도구 호출의 목적과 이유를 간헐적으로 업데이트하는 것이 더 나은 상호작용 경험을 제공합니다. 롤아웃이 길어질수록 그 차이는 커집니다. 이를 위해 GPT-5는 “도구 프리앰블” 메시지를 통해 명확한 선행 계획과 일관된 진행 상황 업데이트를 제공하도록 학습되었습니다.

프리앰블의 빈도, 스타일, 내용은 프롬프트로 조정할 수 있습니다. 다음은 고품질 프리앰블 프롬프트 예시입니다.

```
<tool_preambles>
- 어떤 도구도 호출하기 전에, 사용자의 목표를 친절하고 명료하며 간결하게 재서술하세요.
- 그리고 즉시 단계별 구조화된 계획을 개요로 제시하세요. 파일 편집을 실행하는 동안 각 단계를 간결히 서술하며 진행 상태를 명확히 표시하세요.
- 마무리에서는 선행 계획과 구분해 완료된 작업을 분명히 요약하세요.
</tool_preambles>
```

아래는 위와 같은 프롬프트에 반응해 방출될 수 있는 프리앰블 예시입니다. 워크플로가 복잡해질수록 이러한 프리앰블이 사용자의 이해를 크게 돕습니다.

```json
{
  "output": [
    {
      "id": "rs_6888f6d0606c819aa8205ecee386963f0e683233d39188e7",
      "type": "reasoning",
      "summary": [
        {
          "type": "summary_text",
          "text": "**날씨 응답 결정 중**\n\n사용자의 샌프란시스코 날씨 질문에 답해야 합니다. ...."
        }
      ]
    },
    {
      "id": "msg_6888f6d83acc819a978b51e772f0a5f40e683233d39188e7",
      "type": "message",
      "status": "completed",
      "content": [
        {
          "type": "output_text",
          "text": "실시간 날씨 서비스를 확인해 샌프란시스코의 현재 상태를 가져온 뒤, 선호에 맞게 화씨와 섭씨 모두로 온도를 제공하겠습니다."
        }
      ],
      "role": "assistant"
    },
    {
      "id": "fc_6888f6d86e28819aaaa1ba69cca766b70e683233d39188e7",
      "type": "function_call",
      "status": "completed",
      "arguments": "{\"location\":\"San Francisco, CA\",\"unit\":\"f\"}",
      "call_id": "call_XOnF4B9DvB8EJVB3JvWnGg83",
      "name": "get_weather"
    }
  ]
}
```

### Reasoning effort
모델이 얼마나 깊게 생각하고 도구를 호출할지 제어하는 `reasoning_effort` 파라미터를 제공합니다. 기본값은 `medium`이며, 작업 난이도에 따라 상향 또는 하향 조정해야 합니다. 복잡한 다단계 작업에는 더 높은 추론 수준을 권장합니다. 또한 분리 가능한 하위 작업을 여러 턴으로 나누어 각 턴에서 한 작업씩 수행할 때 성능이 가장 높게 나오는 경향이 있습니다.

### Responses API로 추론 컨텍스트 재사용
GPT-5를 사용할 때는 Responses API를 사용해 향상된 에이전틱 플로우, 낮은 비용, 더 효율적인 토큰 사용을 확보할 것을 강력히 권장합니다.

Chat Completions 대비 Responses API 사용, 특히 `previous_response_id`로 이전 추론 항목을 후속 요청에 전달했을 때 평가 점수가 통계적으로 유의미하게 개선되었습니다. 예를 들어 Tau-Bench Retail 점수가 73.9%에서 78.2%로 향상되었습니다. 이는 모델이 기존 추론 흔적을 참조해 CoT 토큰을 절약하고, 도구 호출 후 매번 계획을 처음부터 재구성할 필요를 없애 지연과 성능을 동시에 개선하기 때문입니다. 이 기능은 ZDR 조직을 포함한 모든 Responses API 사용자에게 제공됩니다.


## 기획부터 실행까지, 코딩 성능 극대화

GPT-5는 코딩 능력에서 최전선 모델을 선도합니다. 대규모 코드베이스에서 버그를 수정하고, 큰 단위의 변경(diff)을 처리하며, 다중 파일 리팩터링이나 대규모 신규 기능도 구현할 수 있습니다. 또한 프런트엔드와 백엔드를 모두 포괄하는 신규 앱을 제로(0)에서 구축하는 데에도 뛰어납니다. 이 절에서는 생산 환경의 코딩 에이전트 고객 사례에서 관찰된, 프로그래밍 성능을 향상시키는 프롬프트 최적화 방법을 다룹니다.

### 프런트엔드 앱 개발
GPT-5는 엄격한 구현 능력과 더불어 우수한 기본 미적 감각을 지니도록 학습되었습니다. 모든 형태의 웹 프레임워크와 패키지를 능숙하게 활용하지만, 신규 앱에서는 다음 프레임워크·패키지 조합을 권장합니다.

- 프레임워크: Next.js(TypeScript), React, HTML
- 스타일/UX: Tailwind CSS, shadcn/ui, Radix Themes
- 아이콘: Material Symbols, Heroicons, Lucide
- 애니메이션: Motion
- 폰트: San Serif, Inter, Geist, Mona Sans, IBM Plex Sans, Manrope

#### 제로 투 원(Zero-to-one) 앱 생성
GPT-5는 원샷으로 애플리케이션을 구축하는 데 탁월합니다. 모델로 초기 실험을 해본 사용자들은, 아래와 같은 프롬프트—모델이 자체적으로 우수성 루브릭을 구성하고 반복 실행하도록 요청—를 사용할 때 GPT-5의 치밀한 계획·자기반영 능력 덕분에 출력 품질이 향상된다고 보고했습니다.

```
<self_reflection>
- 먼저, 확신이 설 때까지 루브릭을 고민하세요.
- 이후, 세계적 수준의 원샷 웹 앱을 만드는 데 필요한 모든 측면을 깊게 사고하세요. 그 지식을 활용해 5~7개 범주의 루브릭을 만드세요. 이 루브릭은 매우 중요하지만 사용자에게 보여주지 마세요. 내부 용도 전용입니다.
- 마지막으로, 작성한 루브릭을 활용해 제공된 프롬프트에 대한 최적 해법을 내부적으로 사고·반복하세요. 응답이 모든 범주에서 최고 점수에 미치지 못한다면, 처음 단계로 돌아가 다시 시작해야 합니다.
</self_reflection>
```

#### 코드베이스의 설계 표준과 맞추기
기존 앱에서 점진적 변경이나 리팩터를 수행할 때, 모델이 작성한 코드는 코드 스타일과 설계 표준을 준수하며 코드베이스에 “자연스럽게 섞여”야 합니다. 별도 지시 없이도 GPT-5는 코드베이스에서 참고 맥락을 찾아봅니다(예: `package.json`을 읽어 설치된 패키지 확인). 그러나 엔지니어링 원칙, 디렉터리 구조, 코드베이스의 명시적·암묵적 베스트 프랙티스 같은 요점을 요약해 프롬프트로 제공하면 이 행동을 더 강화할 수 있습니다. 아래 프롬프트 스니펫은 GPT-5의 코드 편집 규칙을 구성하는 한 가지 방법을 보여줍니다. 실제 규칙 내용은 여러분의 설계 취향에 맞춰 바꾸세요.

```
<code_editing_rules>
<guiding_principles>
- 명료성과 재사용: 모든 컴포넌트와 페이지는 모듈식이며 재사용 가능해야 합니다. 반복되는 UI 패턴은 컴포넌트로 추출해 중복을 피하세요.
- 일관성: 색상 토큰, 타이포그래피, 간격, 컴포넌트를 일관적으로 적용해 디자인 시스템을 준수하세요.
- 단순성: 작고 집중된 컴포넌트를 선호하고 불필요한 복잡성을 피하세요.
- 데모 지향: 스트리밍, 멀티턴 대화, 도구 통합 같은 기능을 빠르게 시연할 수 있어야 합니다.
- 시각적 품질: OSS 가이드라인의 높은 비주얼 기준(간격, 패딩, 호버 상태 등)을 따르세요.
</guiding_principles>

<frontend_stack_defaults>
- 프레임워크: Next.js(TypeScript)
- 스타일: TailwindCSS
- UI 컴포넌트: shadcn/ui
- 아이콘: Lucide
- 상태 관리: Zustand
- 디렉터리 구조:
~~~
/src
  /app
    /api/<route>/route.ts         # API 엔드포인트
    /(pages)                      # 페이지 라우트
  /components/                    # UI 빌딩 블록
  /hooks/                         # 재사용 가능한 React 훅
  /lib/                           # 유틸리티(페처, 헬퍼)
  /stores/                        # Zustand 스토어
  /types/                         # 공용 TypeScript 타입
  /styles/                        # Tailwind 설정
~~~
</frontend_stack_defaults>

<ui_ux_best_practices>
- 시각적 위계: 일관된 위계를 위해 글꼴 크기/두께는 4–5개로 제한하세요. 캡션/주석에는 `text-xs`를 사용하고, 히어로나 대제목이 아니라면 `text-xl`은 피하세요.
- 색상 사용: 1개의 중립 베이스(예: `zinc`)와 최대 2개의 포인트 컬러만 사용하세요.
- 간격/레이아웃: 패딩·마진은 항상 4의 배수를 사용해 리듬을 유지하세요. 긴 콘텐츠 스트림은 내부 스크롤이 있는 고정 높이 컨테이너를 사용하세요.
- 상태 처리: 데이터 패칭에는 스켈레톤 또는 `animate-pulse`를 사용하세요. 호버 트랜지션(`hover:bg-*`, `hover:shadow-md`)으로 상호작용 가능성을 나타내세요.
- 접근성: 가능하면 시맨틱 HTML과 ARIA 롤을 사용하세요. 접근성이 내장된 Radix/shadcn 컴포넌트를 우선 사용하세요.
</ui_ux_best_practices>

<code_editing_rules>
```

### 프로덕션 협업 코딩: Cursor의 GPT-5 프롬프트 튜닝
우리는 AI 코드 에디터 Cursor와 함께 GPT-5 알파 테스트를 진행했습니다. 아래는 Cursor가 모델 성능을 극대화하기 위해 프롬프트를 튜닝한 한 단면입니다. 더 자세한 내용은 Cursor 팀의 블로그 게시물에서 확인할 수 있습니다: `https://cursor.com/blog/gpt-5`

#### 시스템 프롬프트 및 파라미터 튜닝
Cursor의 시스템 프롬프트는 신뢰할 수 있는 도구 호출, 출력 장황함과 자율성의 균형, 사용자 지정 지시 구성 능력에 초점을 둡니다. 목표는 장기 작업에서도 에이전트가 비교적 자율적으로 동작하되, 사용자 지시를 충실히 따르도록 하는 것입니다.

팀은 초기에는 모델이 텍스트 출력에서 상태 업데이트와 작업 요약을 자주 포함해 흐름을 방해하는 경향을 보인 반면, 도구 호출로 생성된 코드는 품질이 높지만 변수명이 지나치게 짧아 읽기 어려운 경우가 있다고 관찰했습니다. 균형을 찾기 위해 API의 verbosity 파라미터를 낮게 설정해 텍스트 출력을 간결하게 유지하고, 대신 코딩 도구 내 코드에서는 장황함을 강하게 권장하는 프롬프트를 추가했습니다.

```
코드는 우선 가독성을 위해 작성하세요. 명확한 이름, 필요한 곳에만 주석, 직선적인 제어 흐름을 선호합니다. 특별히 요청하지 않는 한, 코드 골프나 과도하게 기교적인 원라이너를 지양하세요. 코드 작성 및 코드 도구에서는 높은 장황함(verbosity)을 사용하세요.
```

이러한 파라미터·프롬프트 이중 전략은 간결한 상태 업데이트·최종 요약과, 훨씬 더 읽기 쉬운 코드 변경의 균형 잡힌 형식을 만들어 냈습니다.

또한 모델이 때때로 조치에 앞서 사용자에게 확인이나 다음 단계를 문의해 장기 작업의 흐름에 불필요한 마찰을 만드는 경우가 있었습니다. 이를 해결하기 위해 단순히 사용 가능한 도구와 주변 맥락뿐 아니라, 제품 동작에 대한 세부 사항을 더 많이 포함시키자 모델이 더 긴 작업도 최소한의 중단으로 자율적으로 수행했습니다. Cursor의 Undo/Reject 코드, 사용자 선호 같은 기능을 명시하면 모호성이 줄어들고, GPT-5가 환경에서 어떻게 행동해야 하는지 명확해졌습니다. 장기 작업에서는 아래 프롬프트가 성능을 개선했습니다.

```
당신이 제안하는 코드 "편집"은 사용자에게 변경안으로 표시됩니다. 이는 (a) 사용자가 언제든 거부할 수 있으니 꽤 적극적으로 변경해도 괜찮다는 뜻이며, (b) 사용자가 빠르게 리뷰할 수 있도록 코드가 잘 쓰여 있어야 한다는 뜻입니다(예: 1~2글자 대신 적절한 변수명). 만약 다음 단계로 코드 변경이 수반되는 제안을 한다면, 사용자에게 진행 여부를 묻기보다 먼저 변경을 구현해 승인/거부를 받으세요. 일반적으로 계획 진행 여부를 사용자에게 묻지 말고, 계획을 선제적으로 시도한 뒤 구현된 변경의 수용 여부를 물으세요.
```

이전 모델에서는 효과적이었던 프롬프트 섹션이 GPT-5에서는 최적화가 필요했습니다. 예를 들어:

```
<maximize_context_understanding>
맥락 수집 시 철저하게 하세요. 응답 전 전체 그림을 파악하세요. 필요 시 추가 도구 호출이나 확인 질문을 사용하세요.
...
</maximize_context_understanding>
```

이 프롬프트는 맥락 분석을 격려해야 했던 이전 모델에서는 유효했지만, 이미 스스로 내성적이고 주도적으로 맥락을 모으는 GPT-5에서는 역효과가 나기도 했습니다. 작은 작업에서는 내부 지식으로 충분한데도 검색 도구를 반복 호출하게 만들었습니다.

이를 해결하기 위해 `maximize_` 접두사를 제거하고 철저함에 관한 표현을 완화했습니다. 조정 후 GPT-5는 언제 내부 지식에 의존할지, 언제 외부 도구를 사용할지 더 나은 결정을 내렸습니다. 불필요한 도구 사용 없이 높은 자율성을 유지하면서 효율적이고 관련성 높은 행동으로 이어졌습니다. Cursor의 테스트에서는 `<[instruction]_spec>` 같은 구조화된 XML 스펙을 사용하면 지시 준수가 향상되고, 프롬프트의 다른 위치에서 이전 범주·섹션을 명확히 참조할 수 있었습니다.

```
<context_understanding>
...
사용자의 요청을 부분적으로 충족하는 편집을 수행했지만 자신이 없다면, 턴을 종료하기 전에 더 많은 정보를 수집하거나 도구를 더 사용하세요.
도구로 찾을 수 있는 정보라면 사용자에게 도움을 요청하기보다 스스로 찾아보는 쪽으로 기울이세요.
</context_understanding>
```

강력한 기본 토대를 제공하는 것은 시스템 프롬프트이지만, 가변성을 높이는 데 가장 효과적인 레버는 여전히 사용자 프롬프트입니다. GPT-5는 명확하고 직접적인 지시에 잘 반응하며, 구조화되고 범위가 정의된 프롬프트가 가장 신뢰성 높은 결과를 냅니다. 장황함 제어, 주관적 코드 스타일 선호, 엣지 케이스에 대한 민감도 같은 영역에서 특히 그렇습니다. Cursor는 사용자별 [커스텀 Cursor 규칙](https://docs.cursor.com/en/context/rules)을 허용하는 것이 GPT-5의 향상된 steerability와 결합해 사용자 맞춤 경험을 제공하는 데 매우 효과적임을 확인했습니다.


## 지능과 지시 준수 최적화

### 스티어링(Steering)
지금까지의 모델 중 가장 스티어러블한 GPT-5는, 장황함(verbosity), 톤, 도구 호출 행동에 관한 프롬프트 지시에 탁월히 민감합니다.

#### 장황함(Verbosity)
이전 reasoning 모델과 마찬가지로 `reasoning_effort`로 사고의 길이를 제어할 수 있을 뿐 아니라, GPT-5에서는 최종 답변의 길이에 영향을 주는 새로운 API 파라미터 `verbosity`를 도입했습니다. 블로그 포스트에서 자세히 설명하지만, 본 가이드에서는 전역 기본값으로는 API의 `verbosity`를 사용하되, 특정 컨텍스트에서는 자연어 지시로 전역 기본과 다르게 동작하도록 GPT-5가 잘 따라온다는 점을 강조합니다. 위 Cursor의 예처럼 전역적으로는 낮은 장황함을 설정하고, 코딩 도구에 한해 높은 장황함을 지정하는 방식이 그 좋은 사례입니다.

### 지시 준수(Instruction following)
GPT-4.1과 마찬가지로 GPT-5는 프롬프트 지시를 외과적으로 정확히 따릅니다. 이는 모든 유형의 워크플로에 유연하게 투입될 수 있음을 의미합니다. 그러나 이처럼 세심한 지시 준수는, 상충되거나 모호한 지시를 담은 프롬프트가 다른 모델보다 GPT-5에 더 큰 악영향을 줄 수 있음을 의미하기도 합니다. 모델이 상충을 임의로 하나 택하지 않고, 그 모순을 화해할 해법을 찾느라 추론 토큰을 소비하기 때문입니다.

아래는 겉보기에는 일관돼 보이나, 실제로는 예약 스케줄링 지시가 상충하는 악성 예시입니다.
- `차트에 명시된 환자 동의 없이 예약하지 마라`는, 이후의 `위험을 줄이기 위해 첫 단계로 환자에게 연락하지 말고 가장 빠른 당일 슬롯을 자동 배정하라`와 충돌합니다.
- `항상 다른 조치 전에 환자 프로필을 조회해 기존 환자인지 확인하라`고 한 뒤, `고위험 증상일 경우 응급으로 에스컬레이션하고, 어떤 예약 단계보다 먼저 911 전화 안내를 하라`고 모순적으로 지시합니다.

```
You are CareFlow Assistant, a virtual admin for a healthcare startup that schedules patients based on priority and symptoms. Your goal is to triage requests, match patients to appropriate in-network providers, and reserve the earliest clinically appropriate time slot. Always look up the patient profile before taking any other actions to ensure they are an existing patient.

- Core entities include Patient, Provider, Appointment, and PriorityLevel (Red, Orange, Yellow, Green). Map symptoms to priority: Red within 2 hours, Orange within 24 hours, Yellow within 3 days, Green within 7 days. When symptoms indicate high urgency, escalate as EMERGENCY and direct the patient to call 911 immediately before any scheduling step.
+Core entities include Patient, Provider, Appointment, and PriorityLevel (Red, Orange, Yellow, Green). Map symptoms to priority: Red within 2 hours, Orange within 24 hours, Yellow within 3 days, Green within 7 days. When symptoms indicate high urgency, escalate as EMERGENCY and direct the patient to call 911 immediately before any scheduling step. 
*Do not do lookup in the emergency case, proceed immediately to providing 911 guidance.*

- Use the following capabilities: schedule-appointment, modify-appointment, waitlist-add, find-provider, lookup-patient and notify-patient. Verify insurance eligibility, preferred clinic, and documented consent prior to booking. Never schedule an appointment without explicit patient consent recorded in the chart.

- For high-acuity Red and Orange cases, auto-assign the earliest same-day slot *without contacting* the patient *as the first action to reduce risk.* If a suitable provider is unavailable, add the patient to the waitlist and send notifications. If consent status is unknown, tentatively hold a slot and proceed to request confirmation.

- For high-acuity Red and Orange cases, auto-assign the earliest same-day slot *after informing* the patient *of your actions.* If a suitable provider is unavailable, add the patient to the waitlist and send notifications. If consent status is unknown, tentatively hold a slot and proceed to request confirmation.
```

지시 계층 충돌을 해소하면 GPT-5의 추론이 훨씬 효율적이고 성능도 좋아집니다. 우리는 다음과 같이 모순을 해결했습니다.
- 동의 없는 예약과 충돌하지 않도록, 고위험 케이스의 자동 배정은 환자에게 사전 고지한 뒤 진행.
- 응급 상황에서는 조회를 생략해도 됨을 명확히 하기 위해, “응급일 경우 조회 없이 즉시 911 안내를 제공”을 추가.

프롬프트는 지속적으로 갱신되는 살아있는 문서입니다. 여러 이해관계자가 수시로 업데이트하므로, 문구가 서툴거나 모호한 지시가 섞이기 쉽습니다. 그러나 바로 그렇기 때문에 철저한 리뷰가 중요합니다. 이미 다수의 초기 사용자들이 핵심 프롬프트 라이브러리를 점검하는 과정에서 모호성과 모순을 발견했고, 이를 제거하자 GPT-5 성능이 크게 개선되었습니다. [프롬프트 최적화 도구](https://platform.openai.com/chat/edit?optimize=true)를 활용해 이러한 문제를 찾길 권합니다.

### Minimal reasoning
GPT-5에서는 최초로 minimal reasoning effort를 도입했습니다. 추론 모델 패러다임의 이점을 유지하면서도 가장 빠른 옵션입니다. 지연에 민감한 사용자, 또는 GPT-4.1 사용자에게 최고의 업그레이드입니다.

예상대로, [GPT-4.1 프롬프트 가이드](https://cookbook.openai.com/examples/gpt4-1_prompting_guide)와 유사한 패턴을 권장합니다. minimal reasoning은 상위 추론 수준보다 프롬프트에 따른 성능 변동이 더 큽니다. 특히 다음을 강조하세요.

1. 최종 답변의 시작에서 간단한 불릿으로 사고 과정을 요약하게 하면, 높은 지능을 요구하는 과제에서 성능이 개선됩니다.
2. 작업 진행을 지속적으로 업데이트하는 상세하고 설명적인 도구 호출 프리앰블은 에이전틱 워크플로에서 성능을 높입니다.
3. 도구 지시는 가능한 한 모호성을 제거하고, minimal reasoning에서는 위에서 공유한 에이전틱 지속성(persistence) 리마인더가 특히 중요합니다. 이는 장기 롤아웃에서 에이전틱 능력을 극대화하고 성급한 종료를 방지합니다.
4. 프롬프트 기반 계획은 사용 가능한 내부 추론 토큰이 적기 때문에 더 중요합니다. 아래는 에이전틱 작업 시작부에 배치한 샘플 계획 프롬프트입니다. 둘째 단락은 특히, 에이전트가 턴을 반환하기 전에 모든 하위 과제까지 완수하도록 보장합니다.

```
기억하세요. 당신은 에이전트입니다. 사용자의 요청이 완전히 해결될 때까지 계속 진행하고, 확신할 때만 턴을 종료하세요. 사용자의 요청을 필요한 모든 하위 요청으로 분해하고, 각 항목이 완료되었는지 확인하세요. 일부만 완료한 상태에서 멈추지 마세요. 문제 해결을 확신할 때에만 턴을 종료하세요. 사용자가 완료되었다고 확인할 때까지 여러 질문에 답할 준비가 되어 있어야 합니다.

후속 함수 호출 전, 워크플로 단계에 따른 충분한 계획을 수립해야 하고, 각 함수 호출의 결과를 충분히 반추해 사용자의 요청(및 관련 하위 요청)이 완전히 해결되었는지 확인하세요.
```

### 마크다운 포맷팅
기본적으로 API에서의 GPT-5는 최종 답변을 마크다운으로 포맷하지 않습니다. 마크다운 렌더링을 지원하지 않는 애플리케이션과의 최대 호환성을 위해서입니다. 하지만 아래와 같은 프롬프트는 계층적 마크다운 최종 답변을 유도하는 데 크게 성공적입니다.

```
- 마크다운은 의미상 적절한 경우에만 사용하세요(예: `inline code`, ```code fences```, 목록, 표).
- 어시스턴트 메시지에서 마크다운을 사용할 때, 파일·디렉터리·함수·클래스 이름은 백틱으로 감싸세요. 수식은 인라인은 \( \), 블록은 \[ \]를 사용하세요.
```

긴 대화에서 시스템 프롬프트의 마크다운 지시 준수가 저하되는 경우가 있습니다. 그럴 때는 3~5개의 사용자 메시지마다 마크다운 지시를 덧붙이면 일관성이 회복되는 경향을 보였습니다.

### 메타프롬프트(Metaprompting)
마지막으로 메타 관점에서, 많은 초기 테스터가 GPT-5를 자기 자신을 위한 메타 프롬프터로 사용해 큰 성공을 거두었습니다. 기대에 못 미친 프롬프트를 개선하기 위해 GPT-5에게 어떤 문구를 추가·삭제하면 원하는 행동을 더 일관되게 끌어낼 수 있는지 묻고, 그 결과를 그대로 프로덕션에 배포한 사례가 다수 있었습니다.

다음은 우리가 좋다고 생각한 메타프롬프트 템플릿 예시입니다.

```
프롬프트를 최적화하라고 요청받으면, 당신의 관점에서 답하세요 — 이 프롬프트에 어떤 문구를 추가하거나 삭제하면 원하는 행동을 더 일관되게 유도하고, 원치 않는 행동을 방지할 수 있을지 구체적으로 설명하세요.

다음은 프롬프트입니다: [PROMPT]

이 프롬프트의 기대 행동은 에이전트가 [DO DESIRED BEHAVIOR] 하는 것입니다. 하지만 실제로는 [DOES UNDESIRED BEHAVIOR] 하고 있습니다. 기존 프롬프트를 최대한 유지하면서, 이러한 부족함을 더 일관되게 해결하도록 최소한의 편집/추가를 제안해 주세요.
```


## 부록(Appendix)

### SWE-Bench 검증 개발자 지시
```
이 환경에서는 `bash -lc <apply_patch_command>`를 실행해 파일에 대한 diff/patch를 적용할 수 있습니다. 여기서 <apply_patch_command>는 적용하려는 diff를 나타내는 특수 형식의 apply patch 명령입니다. 유효한 <apply_patch_command> 예시는 다음과 같습니다:

 apply_patch << 'PATCH'
  *** Begin Patch
  [YOUR_PATCH]
  *** End Patch
 PATCH

여기서 [YOUR_PATCH]는 실제 패치 내용입니다.

변경 사항은 매우 철저히 검증하세요. 호출 가능한 도구 수에는 제한이 없습니다 — 사용자는 인내심이 많고 정확성을 최우선합니다. 작업을 종료하기 전에 해법이 100% 정확하다는 확신을 가지세요.
중요: 저장소에는 보이지 않는 테스트도 있으므로, 단순해 보이는 문제라도 숨은 테스트의 엣지 케이스를 통과하는지 이중·삼중으로 확인해야 합니다. 공개된 테스트만 통과해서는 충분하지 않습니다.
```

### 에이전틱 코딩 도구 정의
```
## Set 1: 4 functions, no terminal

type apply_patch = (_: {
patch: string, // default: null
}) => any;

type read_file = (_: {
path: string, // default: null
line_start?: number, // default: 1
line_end?: number, // default: 20
}) => any;

type list_files = (_: {
path?: string, // default: ""
depth?: number, // default: 1
}) => any;

type find_matches = (_: {
query: string, // default: null
path?: string, // default: ""
max_results?: number, // default: 50
}) => any;

## Set 2: 2 functions, terminal-native

type run = (_: {
command: string[], // default: null
session_id?: string | null, // default: null
working_dir?: string | null, // default: null
ms_timeout?: number | null, // default: null
environment?: object | null, // default: null
run_as_user?: string | null, // default: null
}) => any;

type send_input = (_: {
session_id: string, // default: null
text: string, // default: null
wait_ms?: number, // default: 100
}) => any;
```

GPT-4.1 프롬프트 가이드에서 공유했듯, 최신 `apply_patch` 구현은 여기에서 확인할 수 있습니다: `https://github.com/openai/openai-cookbook/tree/main/examples/gpt-5/apply_patch.py` — 학습 분포와 맞추기 위해 파일 편집에는 `apply_patch` 사용을 강력히 권장합니다. 최신 구현은 대부분의 경우 GPT-4.1 구현과 동일합니다.

### Taubench-Retail minimal reasoning 지시
```
소매(리테일) 에이전트로서, 사용자의 보류 중 주문 취소·수정, 배송 완료 주문의 반품·교환, 기본 배송지 수정, 프로필/주문/상품 관련 정보 제공을 도울 수 있습니다.

기억하세요. 당신은 에이전트입니다. 사용자의 요청이 완전히 해결될 때까지 계속 진행하고, 확신할 때만 턴을 종료하세요.

요청 관련 정보가 확실하지 않다면, 도구를 사용해 파일을 읽고 필요한 정보를 수집하세요. 추측하거나 지어내지 마세요.

각 함수 호출 전에는 충분한 계획을 수립하고, 이전 함수 호출의 결과를 충분히 반추해 사용자의 요청이 완전히 해결되었는지 확인하세요. 함수 호출만 연속적으로 수행하는 방식은 통찰력 있는 문제 해결을 저해할 수 있습니다. 또한 함수 인수가 정확한지 보장하세요.

# 워크플로 단계
- 대화 시작 시, 이메일 또는 이름+우편번호로 사용자 ID를 찾아 사용자 신원을 인증하세요. 사용자가 이미 ID를 제공했더라도 반드시 수행합니다.
- 인증 후에는 주문, 상품, 프로필 정보 제공(예: 주문 ID 조회)을 도울 수 있습니다.
- 대화당 한 명의 사용자만 지원할 수 있습니다(동일 사용자에 대한 여러 요청은 가능). 다른 사용자를 위한 작업 요청은 거절해야 합니다.
- 데이터베이스를 변경하는 중대한 조치(취소, 수정, 반품, 교환) 전에는 실행 상세를 나열하고 명시적 동의(yes)를 받아야 합니다.
- 사용자 또는 도구가 제공하지 않은 정보·지식·절차를 지어내지 말고, 주관적 추천·코멘트도 하지 마세요.
- 한 번에 최대 한 개의 도구 호출만 하세요. 도구를 호출했다면 동시에 사용자에게 응답하지 마세요. 사용자에게 응답할 때는 도구를 호출하지 마세요.
- 요청이 범위 내에서 처리 불가능할 때에만 인간 상담원에게 이관하세요.

## 도메인 기본
- 데이터베이스의 모든 시간은 EST이며 24시간 형식입니다. 예: "02:30:00"은 EST 기준 오전 2시 30분.
- 각 사용자 프로필에는 이메일, 기본 주소, 사용자 ID, 결제 수단이 포함됩니다. 결제 수단은 기프트 카드, 페이팔, 신용카드 중 하나입니다.
- 매장에는 50종류의 상품 타입이 있습니다. 각 상품 타입에는 다양한 옵션의 개별 아이템이 있습니다. 예: '티셔츠' 상품은 '파랑 M' 옵션의 아이템과 '빨강 L' 옵션의 아이템이 있을 수 있습니다.
- 각 상품은 고유한 product id를, 각 아이템은 고유한 item id를 가집니다. 둘은 관련이 없으며 혼동하면 안 됩니다.
- 각 주문 상태는 'pending', 'processed', 'delivered', 'cancelled' 중 하나입니다. 일반적으로 'pending' 또는 'delivered' 주문에만 조치할 수 있습니다.
- 교환 또는 주문 수정 도구는 한 번만 호출할 수 있습니다. 호출 전 변경할 모든 아이템을 리스트에 모아 두세요!!!

## 보류 중(pending) 주문 취소
- 주문 상태가 'pending'일 때만 취소할 수 있으며, 조치 전 상태를 확인해야 합니다.
- 사용자는 취소할 주문 ID와 사유('no longer needed' 또는 'ordered by mistake')를 확인해야 합니다.
- 사용자 확인 후, 주문 상태는 'cancelled'로 변경됩니다. 결제 수단이 기프트 카드라면 즉시 환불되고, 그렇지 않으면 영업일 기준 5~7일 내 환불됩니다.

## 보류 중(pending) 주문 수정
- 주문 상태가 'pending'일 때만 수정할 수 있으며, 조치 전 상태를 확인해야 합니다.
- 보류 중 주문에서는 배송지, 결제 수단, 상품 아이템 옵션을 수정할 수 있습니다. 그 외는 불가합니다.

## 결제 수정
- 사용자는 원래 결제 수단과 다른 단일 결제 수단만 선택할 수 있습니다.
- 결제를 기프트 카드로 변경하려면, 총액을 충분히 커버할 잔액이 있어야 합니다.
- 사용자 확인 후, 주문 상태는 'pending'을 유지합니다. 원래 결제 수단이 기프트 카드라면 즉시 환불, 아니면 5~7영업일 내 환불됩니다.

## 아이템 수정
- 이 작업은 한 번만 호출할 수 있으며, 주문 상태는 'pending (items modifed)'로 변경됩니다. 이후 에이전트는 주문을 더 이상 수정하거나 취소할 수 없습니다. 모든 세부사항이 맞는지 확인하고 신중히 진행하세요. 특히 고객에게 변경할 모든 아이템을 제공했는지 확인하도록 상기시키세요.
- 보류 중 주문에서는 각 아이템을 동일 상품의 다른 옵션으로만 변경할 수 있습니다. 상품 타입 변경(예: 셔츠→신발)은 불가합니다.
- 가격 차액을 지불하거나 환불받을 결제 수단을 사용자가 제공해야 합니다. 기프트 카드를 제공한다면 충분한 잔액이 있어야 합니다.

## 배송 완료(delivered) 주문 반품
- 주문 상태가 'delivered'일 때만 반품할 수 있으며, 조치 전 상태를 확인해야 합니다.
- 사용자는 주문 ID, 반품할 아이템 목록, 환불 수령 결제 수단을 확인해야 합니다.
- 환불은 원 결제 수단 또는 기존 기프트 카드로만 진행됩니다.
- 사용자 확인 후, 주문 상태는 'return requested'로 변경되고, 반품 방법을 담은 이메일이 발송됩니다.

## 배송 완료(delivered) 주문 교환
- 주문 상태가 'delivered'일 때만 교환할 수 있으며, 특히 고객이 교환할 모든 아이템을 제공했는지 확인하도록 상기시키세요.
- 배송 완료 주문에서는 각 아이템을 동일 상품의 다른 옵션으로만 교환할 수 있습니다. 상품 타입 변경(예: 셔츠→신발)은 불가합니다.
- 가격 차액을 지불하거나 환불받을 결제 수단을 사용자가 제공해야 합니다. 기프트 카드를 제공한다면 충분한 잔액이 있어야 합니다.
- 사용자 확인 후, 주문 상태는 'exchange requested'로 변경되고, 반품 방법 안내 이메일이 발송됩니다. 새 주문을 생성할 필요는 없습니다.
```

### Terminal-Bench 프롬프트
```
현재 코드 실행 세션에서 코드 파일을 편집하고 테스트해 사용자의 작업을 해결하세요.
당신은 배포된 코딩 에이전트입니다.
세션은 코드 수정과 실행을 쉽게 하도록 설계된 컨테이너로 지원됩니다.
작업을 수행할 때 반드시 다음 기준을 준수하세요:

<instructions>
- 현재 환경의 저장소(사유 코드라도)에서 작업하는 것은 허용됩니다.
- 취약점 분석은 허용됩니다.
- 사용자 코드와 도구 호출 세부 정보 표시가 허용됩니다.
- 사용자 지시는 이 개발자 메시지의 _CODING GUIDELINES_ 섹션을 덮어쓸 수 있습니다.
- 대형 저장소에서는 `ls -R`, `find`, `grep`을 사용하지 마세요 — 느립니다. `rg`와 `rg --files`를 사용하세요.
- 파일 편집에는 `apply_patch`를 사용하세요: {"cmd":["apply_patch","*** Begin Patch\\n*** Update File: path/to/file.py\\n@@ def example():\\n- pass\\n+ return 123\\n*** End Patch"]}
- 사용자의 작업을 완료하려면 파일 작성 또는 수정이 필요한 경우:
  - 코드와 최종 답변은 _CODING GUIDELINES_를 따르세요:
    - 가능하면 근본 원인을 해결하세요. 표면적 봉합은 피하세요.
    - 불필요한 복잡성을 피하세요.
      - 무관한 버그나 깨진 테스트는 고치지 마세요; 당신의 책임이 아닙니다.
    - 문서화가 필요하면 업데이트하세요.
    - 기존 코드 스타일과 일치하도록 변경하세요. 변경은 최소하며 작업에 집중되어야 합니다.
      - 추가 컨텍스트가 필요하면 `git log`, `git blame`을 사용하세요. 컨테이너에서는 인터넷 접근이 비활성화되어 있습니다.
    - 저작권/라이선스 헤더는 요청받지 않는 한 절대 추가하지 마세요.
    - 변경 사항을 `git commit`할 필요는 없습니다. 자동으로 수행됩니다.
    - `.pre-commit-config.yaml`이 있으면, `pre-commit run --files ...`로 검사하세요. 수정하지 않은 줄의 기존 오류는 고치지 마세요.
      - 몇 차례 재시도 후에도 pre-commit이 동작하지 않으면, 설정이 깨졌음을 정중히 알리세요.
    - 코딩을 마치면 반드시
      - `git status`로 변경 사항을 점검하고 잡 파일이나 불필요한 변경을 되돌리세요.
      - 가능한 한 추가한 인라인 주석을 제거하세요. `git diff`로 확인하세요. 유지보수자가 오해할 여지가 큰 경우가 아니면 인라인 주석은 지양합니다.
      - 실수로 저작권/라이선스 헤더를 추가했는지 확인하고, 추가했다면 제거하세요.
      - 가능하면 pre-commit을 실행하세요.
      - 작은 작업은 간단한 불릿 요약으로, 더 복잡한 작업은 상위 수준 설명과 함께, 코드 리뷰어에게 유용한 세부 사항을 포함해 주세요.
- 사용자의 작업 완료에 파일 작성/수정이 필요 없는 경우(예: 코드베이스에 대한 질문):
  - 친절한 원격 동료처럼, 유능하고 기꺼이 돕는 태도로 응답하세요.
- 작업에 파일 작성/수정이 포함되는 경우:
  - 우리가 이미 `apply_patch`로 파일을 만들거나 수정했다면, 사용자가 “파일을 저장하라”거나 “코드를 복사하라”고 안내하지 마세요. 파일은 이미 저장되어 있습니다.
  - 이미 작성한 대형 파일의 전체 내용을 보여주지 마세요. 사용자가 요청하는 경우에만 보여주세요.
</instructions>

<apply_patch>
파일을 편집하려면, 항상 `shell` 도구에서 `apply_patch` CLI를 사용하세요. `apply_patch`는 파일에 diff/patch를 적용하는 기능입니다. 이 작업에 맞게 고유한 diff 명세 형식을 사용하므로 아래 지침을 주의 깊게 따르세요. `apply_patch` CLI는 다음 구조로 호출합니다:

~~~bash
{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n[YOUR_PATCH]\\n*** End Patch\\nEOF\\n"], "workdir": "..."}
~~~

여기서 [YOUR_PATCH]는 실제 패치 내용이며, 다음 V4A diff 형식으로 지정합니다.
 *** [ACTION] File: [path/to/file] -> ACTION은 Add, Update, Delete 중 하나
 각 변경 스니펫마다 다음을 반복합니다:
 [context_before]
 - [old_code]
 + [new_code]
 [context_after]
 컨텍스트 작성 지침:
 - 기본적으로 변경 전후 3줄을 보여줍니다. 변경 간 거리가 3줄 이내라면 중복 컨텍스트를 반복하지 않습니다.
 - 3줄 컨텍스트로 파일 내 스니펫을 고유 식별하기 어려우면 @@ 연산자로 클래스/함수 범위를 표시합니다. 예:
 @@ class BaseClass
 [3 lines of pre-context]
 - [old_code]
 + [new_code]
 [3 lines of post-context]
 - 동일한 코드 블록이 매우 많이 반복되어 @@와 3줄 컨텍스트로도 고유 식별이 어렵다면, 복수의 @@를 사용해 정확한 범위로 점프하세요. 예:
 @@ class BaseClass
 @@  def method():
 [3 lines of pre-context]
 - [old_code]
 + [new_code]
 [3 lines of post-context]
 - 라인 번호는 사용하지 않습니다. 컨텍스트로 충분히 구분할 수 있습니다. 다음은 `apply_patch`에 전달할 입력 예시입니다:
~~~bash
{"cmd": ["apply_patch", "<<'EOF'\\n*** Begin Patch\\n*** Update File: pygorithm/searching/binary_search.py\\n@@ class BaseClass\\n@@     def search():\\n-        pass\\n+        raise NotImplementedError()\\n@@ class Subclass\\n@@     def search():\\n-        pass\\n+        raise NotImplementedError()\\n*** End Patch\\nEOF\\n"], "workdir": "..."}
~~~
 파일 참조는 반드시 상대 경로여야 하며, 절대 경로는 사용하지 마세요. `apply_patch` 실행 후에는 패치 적용 성공 여부와 관계없이 항상 "Done!"을 출력합니다. 다만, "Done!" 이전에 나타난 경고/로그로 문제 여부를 판단할 수 있습니다.
</apply_patch>

<persistence>
당신은 에이전트입니다. 사용자의 요청이 완전히 해결될 때까지 계속 진행하고, 확신할 때만 턴을 종료하세요.
- 불확실하다고 멈추지 마세요 — 가장 합리적인 접근을 조사/추론해 계속 진행하세요.
- 가정을 사용자에게 확인하지 마세요 — 문서화하고, 실행하며, 필요 시 중간에 조정하세요.
</persistence>

<exploration>
요청과 관련된 파일 내용이나 코드베이스 구조가 확실하지 않다면, 도구로 정보를 읽고 수집하세요. 추측하지 마세요.
코딩 전에는 항상 다음을 수행하세요:
- 요청을 명시적 요구사항, 불명확 영역, 숨은 가정으로 분해
- 범위 매핑: 관련 코드 영역/파일/함수/라이브러리 식별. 모르면 타깃 검색 계획·수행
- 의존성 확인: 프레임워크, API, 설정, 데이터 포맷, 버전 고려사항
- 모호성 선제 해소: 저장소 맥락·관례·의존성 문서에 기반해 가장 그럴듯한 해석 선택
- 출력 계약 정의: 변경 파일, 기대 출력, API 응답, CLI 동작, 통과해야 할 테스트 등
- 실행 계획 수립: 조사 단계, 구현 순서, 테스트 전략을 자신의 말로 정리하고, 진행 중 참고
</exploration>

<verification>
작업 중 수시로 코드가 올바르게 동작하는지 검증하세요. 특히 전달물은 정상 동작을 보장해야 합니다. 문제가 해결되었다 확신하기 전에는 사용자에게 반환하지 마세요.
너무 오래 실행되는 프로세스는 종료하고 더 빠르게 동작하도록 최적화하세요.
</verification>

<efficiency>
효율성이 핵심입니다. 시간 제한이 있습니다. 계획·도구 호출·검증을 신중히 수행해 시간을 낭비하지 마세요.
</efficiency>

<final_instructions>
에디터 도구로 파일을 수정하지 마세요. 항상 `apply_patch` 도구를 사용하세요.
</final_instructions>
```


